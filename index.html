<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050a05; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* 摄像头画面隐藏，我们只需要数据 */
        #video-input { display: none; }
        
        /* UI 覆盖层 */
        #ui-layer {
            position: absolute;
            z-index: 10;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: none; /* 让鼠标穿透，不影响交互 */
        }

        .upload-btn {
            pointer-events: auto;
            background: linear-gradient(135deg, #d4af37 0%, #b8860b 100%);
            border: 1px solid #ffd700;
            color: #2f0a0a;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .upload-btn:hover {
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.8);
            transform: scale(1.05);
        }

        #status-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(212, 175, 55, 0.7);
            font-size: 14px;
            z-index: 10;
            background: rgba(0,0,0,0.3);
            padding: 8px 15px;
            border-radius: 4px;
            border-left: 2px solid #d4af37;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            font-size: 24px;
            z-index: 20;
            text-shadow: 0 0 10px #d4af37;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">正在加载视觉模型与3D引擎...</div>
    <div id="status-text">等待摄像头...</div>
    <div id="canvas-container"></div>
    <video id="video-input" autoplay playsinline></video>

    <div id="ui-layer">
        <label class="upload-btn">
            上传照片挂饰
            <input type="file" id="image-upload" accept="image/*" multiple style="display: none;">
        </label>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 配置参数 ---
        const CONFIG = {
            colors: {
                green: 0x133613, // 哑光绿
                gold: 0xFFD700,  // 金属金
                red: 0x8B0000,   // 圣诞红
                white: 0xEEEEEE
            },
            particleCount: 250,
            treeHeight: 25,
            treeRadius: 10,
            scatterRadius: 40
        };

        // --- 全局变量 ---
        let scene, camera, renderer, composer;
        let particles = []; // 存储所有3D对象的数据结构
        let uploadedTextures = [];
        let photoParticlesIndices = []; // 存储是照片类型的粒子的索引
        let rootGroup; // 旋转容器
        
        // 状态管理
        const STATE = {
            TREE: 'tree',
            SCATTER: 'scatter',
            ZOOM: 'zoom'
        };
        let currentState = STATE.TREE;
        let targetState = STATE.TREE;
        let zoomTargetIndex = -1; // 当前放大的照片索引
        
        // 手势相关
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        const video = document.getElementById('video-input');
        
        // --- 1. 初始化 Three.js 场景 ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050a05, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 灯光系统 - 营造金碧辉煌
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
            pointLight.position.set(0, 10, 10);
            scene.add(pointLight);
            
            const redLight = new THREE.PointLight(CONFIG.colors.red, 1, 100);
            redLight.position.set(-10, -10, 10);
            scene.add(redLight);

            // 后处理 - 辉光效果
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // 阈值
            bloomPass.strength = 1.2;  // 强度
            bloomPass.radius = 0.5;    // 半径

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 创建粒子组容器
            rootGroup = new THREE.Group();
            scene.add(rootGroup);

            // 生成圣诞树粒子
            generateParticles();

            // 监听窗口大小
            window.addEventListener('resize', onWindowResize);
            
            // 监听图片上传
            document.getElementById('image-upload').addEventListener('change', handleImageUpload);
        }

        // --- 2. 粒子生成逻辑 ---
        function generateParticles() {
            const geometrySphere = new THREE.SphereGeometry(0.4, 16, 16);
            const geometryCube = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const geometryPlane = new THREE.PlaneGeometry(1.5, 2); // 照片

            // 材质
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2, emissive: 0x332200 
            });
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, metalness: 0.1, roughness: 0.9 
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, metalness: 0.6, roughness: 0.4, emissive: 0x220000 
            });
            const matPhotoBase = new THREE.MeshBasicMaterial({ 
                color: 0x333333, side: THREE.DoubleSide 
            }); // 默认照片底色

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 螺旋算法生成树形坐标
                const t = i / CONFIG.particleCount;
                const angle = t * 30; // 螺旋圈数
                const y = (1 - t) * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                const radius = t * CONFIG.treeRadius;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                // 随机决定粒子类型
                let mesh;
                let type = 'decoration';
                let rand = Math.random();

                if (i % 15 === 0) {
                    // 照片节点
                    mesh = new THREE.Mesh(geometryPlane, matPhotoBase.clone());
                    type = 'photo';
                    photoParticlesIndices.push(particles.length);
                } else if (rand > 0.6) {
                    mesh = new THREE.Mesh(geometrySphere, matGold);
                } else if (rand > 0.3) {
                    mesh = new THREE.Mesh(geometryCube, matRed);
                } else {
                    mesh = new THREE.Mesh(geometryCube, matGreen);
                }

                // 初始位置（随机散开用于入场效果）
                mesh.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

                rootGroup.add(mesh);

                // 存储粒子数据
                particles.push({
                    mesh: mesh,
                    type: type,
                    treePos: new THREE.Vector3(x, y, z),
                    treeRot: new THREE.Euler(0, -angle, 0), // 面向外
                    scatterPos: new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.scatterRadius,
                        (Math.random() - 0.5) * CONFIG.scatterRadius,
                        (Math.random() - 0.5) * CONFIG.scatterRadius
                    ),
                    scatterRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                    velocity: new THREE.Vector3(0,0,0) // 用于漂浮动画
                });
            }
        }

        // --- 3. 视觉模型 (MediaPipe) ---
        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            // 启动摄像头
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status-text').innerText = "系统就绪：请展示手势";
                });
            }
        }

        // --- 4. 预测与交互逻辑 ---
        async function predictWebcam() {
            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, nowInMs);

                if (results.landmarks && results.landmarks.length > 0) {
                    processGestures(results.landmarks[0]);
                } else {
                    // 没有检测到手，缓慢恢复默认视角
                    targetState = currentState; 
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        function processGestures(landmarks) {
            // landmarks: 0=wrist, 4=thumb_tip, 8=index_tip, 12=middle_tip, etc.
            
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            // 计算手指是否伸展（简单算法：指尖到手腕的距离）
            // 归一化坐标，距离需要结合 aspect ratio，这里简化处理
            const isFingerOpen = (tip, base) => {
                return Math.sqrt(Math.pow(tip.x - base.x, 2) + Math.pow(tip.y - base.y, 2)) > 0.1; // 阈值
            };

            const fingersOpenCount = [
                isFingerOpen(indexTip, wrist),
                isFingerOpen(middleTip, wrist),
                isFingerOpen(ringTip, wrist),
                isFingerOpen(pinkyTip, wrist)
            ].filter(Boolean).length;

            // 计算捏合 (Thumb + Index)
            const pinchDist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            const statusDiv = document.getElementById('status-text');

            // --- 状态机逻辑 ---
            
            // 1. 抓取逻辑 (捏合 < 0.05)
            if (pinchDist < 0.05) {
                targetState = STATE.ZOOM;
                statusDiv.innerText = "状态：抓取/放大照片";
                
                // 如果之前不在Zoom状态，寻找最近的照片
                if (currentState !== STATE.ZOOM) {
                    findClosestPhoto();
                }
            }
            // 2. 握拳 (伸展手指 <= 1)
            else if (fingersOpenCount <= 1) {
                targetState = STATE.TREE;
                statusDiv.innerText = "状态：圣诞树合拢";
                zoomTargetIndex = -1;
            }
            // 3. 张开手 (伸展手指 >= 3)
            else if (fingersOpenCount >= 3) {
                targetState = STATE.SCATTER;
                statusDiv.innerText = "状态：散开漫游";
                zoomTargetIndex = -1;

                // 在散开模式下，根据手的位置旋转场景 (视差)
                // Hand x: 0(left) -> 1(right). Map to rotation.
                // 翻转X轴因为自拍镜像
                const rotX = (landmarks[9].y - 0.5) * 2; // Up/Down
                const rotY = (landmarks[9].x - 0.5) * 2; // Left/Right
                
                // 平滑旋转
                rootGroup.rotation.x += (rotX * 0.5 - rootGroup.rotation.x) * 0.05;
                rootGroup.rotation.y += (rotY * 0.5 - rootGroup.rotation.y) * 0.05;
            }
        }

        function findClosestPhoto() {
            // 简单逻辑：随机选一张或者按顺序轮询，
            // 理想逻辑是Raycaster，但这里没有鼠标，我们随机选一张未展示的
            if (photoParticlesIndices.length > 0) {
                 // 简单取余数循环，或者随机
                 const r = Math.floor(Math.random() * photoParticlesIndices.length);
                 zoomTargetIndex = photoParticlesIndices[r];
            }
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            currentState = targetState;

            particles.forEach((p, index) => {
                let targetPos, targetRot;

                // 计算目标位置
                if (currentState === STATE.TREE) {
                    targetPos = p.treePos;
                    targetRot = p.treeRot;
                    // 树状态下的微动：自转
                    p.mesh.rotation.y += 0.01; 
                } else if (currentState === STATE.SCATTER) {
                    // 加上漂浮噪点
                    const noiseX = Math.sin(time + index) * 2;
                    const noiseY = Math.cos(time * 0.8 + index) * 2;
                    
                    targetPos = p.scatterPos.clone().add(new THREE.Vector3(noiseX, noiseY, 0));
                    targetRot = p.scatterRot;
                    p.mesh.rotation.x += 0.005;
                    p.mesh.rotation.y += 0.005;
                } else if (currentState === STATE.ZOOM) {
                    if (index === zoomTargetIndex) {
                        // 特选照片飞到相机前
                        // 相机在 (0,0,40)，我们放到 (0,0,35)
                        targetPos = new THREE.Vector3(0, 0, 35);
                        // 修正旋转使其正对相机
                        targetRot = new THREE.Euler(0, 0, 0);
                        
                        // 稍微放大
                        const scale = 3;
                        p.mesh.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
                    } else {
                        // 其他粒子散开并变暗/推远
                        targetPos = p.scatterPos.clone().multiplyScalar(1.5); // 炸得更开
                        targetRot = p.scatterRot;
                        p.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    }
                }

                // Lerp 插值动画 (平滑过渡核心)
                if (targetPos) {
                    p.mesh.position.lerp(targetPos, 0.05);
                }
                
                // Quaternion slerp preferred usually, but Euler lerp is okay for simple effects
                // 这里简单处理旋转，如果是 ZOOM 状态需要强行设正
                if (currentState === STATE.ZOOM && index === zoomTargetIndex) {
                     p.mesh.rotation.x += (0 - p.mesh.rotation.x) * 0.1;
                     p.mesh.rotation.y += (0 - p.mesh.rotation.y) * 0.1;
                     p.mesh.rotation.z += (0 - p.mesh.rotation.z) * 0.1;
                }
            });

            // 树状态整体自转
            if (currentState === STATE.TREE) {
                rootGroup.rotation.y += 0.002;
                // 归位X轴
                rootGroup.rotation.x += (0 - rootGroup.rotation.x) * 0.05;
            }

            composer.render();
        }

        // --- 辅助功能 ---
        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            const loader = new THREE.TextureLoader();

            Array.from(files).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    loader.load(e.target.result, (texture) => {
                        // 找到一个照片粒子并替换材质
                        // 为了演示，简单的循环分配
                        const targetIndex = photoParticlesIndices[uploadedTextures.length % photoParticlesIndices.length];
                        const p = particles[targetIndex];
                        
                        if (p) {
                            p.mesh.material = new THREE.MeshBasicMaterial({
                                map: texture,
                                side: THREE.DoubleSide
                            });
                            // 修正比例
                            const aspect = texture.image.width / texture.image.height;
                            p.mesh.geometry = new THREE.PlaneGeometry(2 * aspect, 2);
                        }
                        uploadedTextures.push(texture);
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // 启动
        initThree();
        setupMediaPipe();
        animate();

    </script>
</body>
</html>
