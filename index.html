<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圣诞手势粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        .input_video { display: none; }
        
        /* UI 覆盖层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        #header {
            text-align: center;
            color: #ffd700;
            text-shadow: 0 0 10px #ffcc00, 0 0 20px #ff0000;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; }
        p { color: #aaa; font-size: 14px; margin-top: 5px; }

        #controls {
            pointer-events: auto;
            background: rgba(0, 20, 0, 0.6);
            border: 1px solid #ffd700;
            padding: 15px;
            border-radius: 10px;
            align-self: flex-start;
            backdrop-filter: blur(5px);
            color: #fff;
        }

        #status-panel {
            position: absolute;
            top: 20px; right: 20px;
            text-align: right;
        }
        .status-item {
            background: rgba(0,0,0,0.5);
            color: #ffd700;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-family: monospace;
            border-left: 3px solid #cc0000;
        }

        /* 上传按钮样式 */
        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
        }
        .btn {
            border: 1px solid #ffd700;
            color: #ffd700;
            background-color: transparent;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover {
            background-color: #ffd700;
            color: #000;
            box-shadow: 0 0 15px #ffd700;
        }
        .upload-btn-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; font-size: 24px; text-shadow: 0 0 10px #ff0000;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading">正在启动魔法引擎...</div>

    <div id="ui-layer">
        <div id="header">
            <h1>Magic Christmas</h1>
            <p>Gesture Controlled Particle System</p>
        </div>

        <div id="controls">
            <div style="margin-bottom: 10px; color: #ddd; font-size: 12px;">上传照片以生成照片云</div>
            <div class="upload-btn-wrapper">
                <button class="btn">上传照片</button>
                <input type="file" id="photo-upload" multiple accept="image/*" />
            </div>
            <div id="photo-count" style="margin-top: 5px; font-size: 12px; color: #888;">已加载 0 张照片</div>
        </div>

        <div id="status-panel">
            <div class="status-item" id="gesture-status">等待手势...</div>
            <div class="status-item" id="mode-status">当前模式: 圣诞树 (合拢)</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video"></video>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Tween.js for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <!-- Shaders from 2.html for the particle effect -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uDispersalState; 

        attribute float size;
        attribute vec3 customColor;
        attribute vec3 basePosition; 
        attribute vec3 explosionDirection;

        varying vec3 vColor;

        void main() {
            vColor = customColor;
            vec3 dispersedPosition = basePosition + explosionDirection * 25.0;
            vec3 newPosition = mix(basePosition, dispersedPosition, uDispersalState);

            newPosition.x += sin(uTime * 1.5 + basePosition.y * 0.3) * 0.08 * (1.0 - uDispersalState * 0.5);
            newPosition.z += cos(uTime * 1.5 + basePosition.y * 0.3) * 0.08 * (1.0 - uDispersalState * 0.5);
            newPosition.y += sin(uTime * 2.0 + basePosition.x) * 0.5 * uDispersalState;

            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
            
            float currentSize = size * (1.0 + uDispersalState * 0.5);
            gl_PointSize = currentSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float intensity = 1.0 - r; 
            gl_FragColor = vec4(vColor * intensity, 1.0); 
        }
    </script>

    <script>
        // --- 配置与状态 ---
        const CONFIG = {
            particleCount: 600,
            colors: {
                green: 0x133613, // 哑光绿
                gold: 0xffd700,  // 金属金
                red: 0xcc0000,   // 圣诞红
                white: 0xffffff
            },
            bloom: {
                strength: 2.0,
                radius: 0.5,
                threshold: 0.2
            }
        };

        const STATE = {
            TREE: 'tree',       // 合拢
            DISPERSED: 'dispersed', // 散开
            ZOOM: 'zoom'        // 照片放大
        };

        let currentState = STATE.TREE;
        let targetRotation = { x: 0, y: 0 };
        let isHandPresent = false;
        let uploadedTextures = [];
        
        // --- Three.js 变量 ---
        let scene, camera, renderer, composer;
        let particlesGroup;
        let particles = []; // 存储所有粒子对象 { mesh, treePos, scatterPos, type, originalScale }
        let raycaster = new THREE.Raycaster();
        let zoomedObject = null; // 当前放大的对象

        // 新增：背景粒子系统变量
        let bgParticleSystem, bgUniforms;
        let currentBgDispersal = 0.0;

        // --- 初始化 ---
        function init() {
            initThree();
            createParticles(); // 原有的交互性粒子
            createBgParticles(); // 新增：背景氛围粒子
            initMediaPipe();
            initEvents();
            animate();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020502); // 深深绿背景
            scene.fog = new THREE.FogExp2(0x020502, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 灯光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // 增加环境光
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffd700, 2.5, 80); // 增加主光强度和范围
            pointLight.position.set(5, 10, 5);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xff0000, 1.8, 80); // 增加辅光强度
            pointLight2.position.set(-5, 5, 10);
            scene.add(pointLight2);

            // 后处理 (辉光)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloom.strength,
                CONFIG.bloom.radius,
                CONFIG.bloom.threshold
            );
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            particlesGroup = new THREE.Group();
            scene.add(particlesGroup);
        }

        function createParticles() {
            // 材质
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, roughness: 0.4, metalness: 0.6, emissive: 0x052005, emissiveIntensity: 0.2 
            });
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, roughness: 0.1, metalness: 1.0, emissive: 0xffd700, emissiveIntensity: 0.8
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, roughness: 0.2, metalness: 0.6, emissive: 0xaa0000, emissiveIntensity: 0.4
            });
            const matPhotoDefault = new THREE.MeshBasicMaterial({ 
                color: 0xaaaaaa, side: THREE.DoubleSide 
            }); // 默认照片占位

            // 几何体
            const geoSphere = new THREE.SphereGeometry(0.3, 16, 16);
            const geoBox = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const geoPlane = new THREE.PlaneGeometry(1.5, 1.0); // 照片比例

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh, type;
                const rand = Math.random();

                // 随机分配类型
                if (rand > 0.95) {
                    // 照片 (5%)
                    mesh = new THREE.Mesh(geoPlane, matPhotoDefault.clone());
                    type = 'photo';
                } else if (rand > 0.8) {
                    // 金球 (15%)
                    mesh = new THREE.Mesh(geoSphere, matGold);
                    type = 'gold';
                } else if (rand > 0.6) {
                    // 红球/方块 (20%)
                    mesh = new THREE.Mesh(Math.random() > 0.5 ? geoSphere : geoBox, matRed);
                    type = 'red';
                } else {
                    // 绿球/方块 (60%) - 树的主体
                    mesh = new THREE.Mesh(Math.random() > 0.5 ? geoSphere : geoBox, matGreen);
                    type = 'green';
                }

                // 1. 计算树形位置 (圆锥螺旋)
                // y 从 -10 到 10
                const y = (Math.random() * 20) - 10; 
                const level = (y + 10) / 20; // 0 (bottom) to 1 (top)
                const radius = (1.0 - level) * 8 + 0.5; // 底部宽，顶部窄
                const angle = Math.random() * Math.PI * 2;
                
                const treeX = Math.cos(angle) * radius;
                const treeZ = Math.sin(angle) * radius;
                const treePos = new THREE.Vector3(treeX, y, treeZ);

                // 2. 计算散开位置 (随机分布)
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 20
                );

                // 初始位置设为树形
                mesh.position.copy(treePos);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                
                // 随机大小变化
                const scale = Math.random() * 0.5 + 0.5;
                mesh.scale.set(scale, scale, scale);

                particlesGroup.add(mesh);
                
                particles.push({
                    mesh: mesh,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    type: type,
                    originalScale: new THREE.Vector3(scale, scale, scale),
                    originalRotation: mesh.rotation.clone()
                });
            }
        }

        function createBgParticles() {
            const particleCount = 15000; 
            const geometry = new THREE.BufferGeometry();
            
            const basePositions = [];
            const colors = [];
            const sizes = [];
            const explosionDirections = []; 

            const colorGreen = new THREE.Color(0x133613);
            const colorGold = new THREE.Color(0xffd700);
            const colorRed = new THREE.Color(0xcc0000);

            for (let i = 0; i < particleCount; i++) {
                const height = Math.random() * 20 - 10; // -10 to 10
                const level = (height + 10) / 20; 
                const radius = Math.pow((1.0 - level), 1.5) * 8 + 0.5; 
                const angle = i * 0.1 + level * 25.0;

                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 1.0;
                const y = height;
                const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 1.0;

                basePositions.push(x, y, z);

                let dir = new THREE.Vector3(x, y, z).normalize();
                dir.x += (Math.random() - 0.5) * 2.0;
                dir.y += (Math.random() - 0.5) * 2.0; 
                dir.z += (Math.random() - 0.5) * 2.0;
                dir.normalize();
                explosionDirections.push(dir.x, dir.y, dir.z);

                let color, size;
                const rand = Math.random();
                if (rand > 0.95) { color = colorGold; size = Math.random() * 0.6 + 0.4; }
                else if (rand > 0.9) { color = colorRed; size = Math.random() * 0.6 + 0.4; }
                else { color = colorGreen; size = Math.random() * 0.3 + 0.1; }
                
                // 稍微增加一点亮度
                color.multiplyScalar(1.5);

                colors.push(color.r, color.g, color.b);
                sizes.push(size);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(basePositions, 3));
            geometry.setAttribute('basePosition', new THREE.Float32BufferAttribute(basePositions, 3));
            geometry.setAttribute('explosionDirection', new THREE.Float32BufferAttribute(explosionDirections, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            bgUniforms = {
                uTime: { value: 0.0 },
                uDispersalState: { value: 0.0 }
            };

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: bgUniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            bgParticleSystem = new THREE.Points(geometry, shaderMaterial);
            scene.add(bgParticleSystem);
        }

        // --- 状态切换逻辑 ---
        function switchState(newState, handData = null) {
            if (currentState === newState && newState !== STATE.ZOOM) return;
            
            // 如果从 ZOOM 退出，先恢复被放大的对象
            if (currentState === STATE.ZOOM && newState !== STATE.ZOOM) {
                resetZoomedObject();
            }

            currentState = newState;
            updateStatusUI();

            if (newState === STATE.TREE) {
                // 回到树形
                particles.forEach(p => {
                    new TWEEN.Tween(p.mesh.position)
                        .to(p.treePos, 1500)
                        .easing(TWEEN.Easing.Elastic.Out)
                        .start();
                    new TWEEN.Tween(p.mesh.rotation)
                        .to({x: p.originalRotation.x, y: p.originalRotation.y, z: p.originalRotation.z}, 1500)
                        .start();
                    new TWEEN.Tween(p.mesh.scale)
                        .to(p.originalScale, 1000)
                        .start();
                });
                // 重置整体旋转
                new TWEEN.Tween(particlesGroup.rotation)
                    .to({ x: 0, y: 0 }, 1000)
                    .start();

            } else if (newState === STATE.DISPERSED) {
                // 散开
                particles.forEach(p => {
                    new TWEEN.Tween(p.mesh.position)
                        .to(p.scatterPos, 2000)
                        .easing(TWEEN.Easing.Exponential.Out)
                        .start();
                });
            } else if (newState === STATE.ZOOM && handData) {
                // 抓取放大
                handleGrab(handData);
            }
        }

        function handleGrab(handData) {
            // 1. 将手部坐标 (0-1) 转换为屏幕坐标 (-1 to 1)
            const mouse = new THREE.Vector2();
            mouse.x = (handData.x * 2) - 1; // MediaPipe x is 0-1 (left-right) -> -1 to 1? No, MP x is 0(left)-1(right). Three is -1(left) to 1(right).
            // Wait, MediaPipe x is normalized 0.0 - 1.0. 
            // Three.js NDC: -1 (left) to +1 (right).
            // So: (x * 2) - 1.
            // MediaPipe y is 0(top) - 1(bottom).
            // Three.js NDC: +1 (top) to -1 (bottom).
            // So: -(y * 2) + 1.
            
            // 注意：MediaPipe 镜像问题。通常 input_video 是镜像的，但 landmarks 坐标也是对应的。
            // 我们假设 landmarks.x 对应屏幕 x。
            
            mouse.x = (handData.x * 2) - 1;
            mouse.y = -(handData.y * 2) + 1;

            raycaster.setFromCamera(mouse, camera);

            // 寻找最近的“照片”类型的粒子
            const photoMeshes = particles.filter(p => p.type === 'photo').map(p => p.mesh);
            const intersects = raycaster.intersectObjects(photoMeshes);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                zoomObject(hit);
            } else {
                // 如果没抓到照片，随机抓一张或者保持散开
                // 为了体验好，如果没有抓到，我们找离手最近的一张照片
                let minDist = Infinity;
                let closestMesh = null;
                
                // 简单的屏幕空间距离检查
                particles.forEach(p => {
                    if (p.type === 'photo') {
                        const pos = p.mesh.position.clone().project(camera);
                        const dx = pos.x - mouse.x;
                        const dy = pos.y - mouse.y;
                        const dist = dx*dx + dy*dy;
                        if (dist < minDist) {
                            minDist = dist;
                            closestMesh = p.mesh;
                        }
                    }
                });

                if (closestMesh && minDist < 0.2) { // 阈值
                    zoomObject(closestMesh);
                }
            }
        }

        function zoomObject(mesh) {
            if (zoomedObject === mesh) return;
            resetZoomedObject(); // 先重置之前的

            zoomedObject = mesh;
            
            // 记录当前位置以便恢复
            // (实际上我们恢复时直接用 scatterPos，所以不需要特意存，除非在动画中途)

            // 移动到相机前方
            const targetPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5));
            
            new TWEEN.Tween(mesh.position)
                .to(targetPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            
            // 放大
            new TWEEN.Tween(mesh.scale)
                .to({ x: 3, y: 3, z: 3 }, 1000)
                .start();
            
            // 面向相机
            new TWEEN.Tween(mesh.rotation)
                .to({ x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }, 1000)
                .start();
        }

        function resetZoomedObject() {
            if (!zoomedObject) return;
            
            // 找回原来的粒子数据
            const p = particles.find(item => item.mesh === zoomedObject);
            if (p) {
                new TWEEN.Tween(zoomedObject.position)
                    .to(currentState === STATE.TREE ? p.treePos : p.scatterPos, 1000)
                    .start();
                new TWEEN.Tween(zoomedObject.scale)
                    .to(p.originalScale, 1000)
                    .start();
                new TWEEN.Tween(zoomedObject.rotation)
                    .to({x: p.originalRotation.x, y: p.originalRotation.y, z: p.originalRotation.z}, 1000)
                    .start();
            }
            zoomedObject = null;
        }

        // --- MediaPipe 逻辑 ---
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start()
                .then(() => document.getElementById('loading').style.display = 'none')
                .catch(e => console.error(e));
        }

        function onHandsResults(results) {
            const statusEl = document.getElementById('gesture-status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 识别手势
                // 计算手指伸展情况
                const fingerTips = [8, 12, 16, 20];
                const fingerDips = [6, 10, 14, 18]; // 关节
                let extendedFingers = 0;
                
                // 拇指判断 (简单版：看x坐标差异)
                const thumbTip = landmarks[4];
                const thumbIp = landmarks[3];
                // 简单的距离判断
                if (distance(thumbTip, landmarks[0]) > distance(thumbIp, landmarks[0]) * 1.1) {
                    extendedFingers++;
                }

                for (let i = 0; i < 4; i++) {
                    if (distance(landmarks[fingerTips[i]], landmarks[0]) > distance(landmarks[fingerDips[i]], landmarks[0])) {
                        extendedFingers++;
                    }
                }

                // 抓取判断 (食指指尖与拇指指尖距离)
                const pinchDist = distance(landmarks[8], landmarks[4]);
                const isPinching = pinchDist < 0.05;

                // 状态机逻辑
                if (isPinching) {
                    statusEl.textContent = "手势: 抓取 (查看照片)";
                    // 传入食指指尖位置作为“抓取点”
                    switchState(STATE.ZOOM, landmarks[8]); 
                } else if (extendedFingers >= 4) {
                    statusEl.textContent = "手势: 张开 (散开)";
                    switchState(STATE.DISPERSED);
                } else if (extendedFingers <= 1) {
                    statusEl.textContent = "手势: 握拳 (合拢)";
                    switchState(STATE.TREE);
                } else {
                    statusEl.textContent = "手势: ...";
                }

                // 旋转逻辑 (仅在散开态且非抓取时)
                if (currentState === STATE.DISPERSED && !isPinching) {
                    // 使用手掌中心 (9) 映射旋转
                    const palm = landmarks[9];
                    // 映射 0-1 到 -1 到 1
                    const x = (palm.x - 0.5) * 2; 
                    const y = (palm.y - 0.5) * 2;
                    
                    // 目标旋转角度
                    targetRotation.y = x * Math.PI; // 左右移动 -> 绕Y轴转
                    targetRotation.x = y * Math.PI * 0.5; // 上下移动 -> 绕X轴转
                }

            } else {
                isHandPresent = false;
                statusEl.textContent = "未检测到手部";
            }
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // --- 事件处理 ---
        function initEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // 照片上传
            document.getElementById('photo-upload').addEventListener('change', function(e) {
                const files = e.target.files;
                if (!files.length) return;

                document.getElementById('photo-count').textContent = `已加载 ${files.length} 张照片`;

                // 清空旧纹理
                uploadedTextures = [];
                
                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        const tex = new THREE.Texture(img);
                        img.onload = () => tex.needsUpdate = true;
                        uploadedTextures.push(tex);
                        updatePhotoParticles();
                    };
                    reader.readAsDataURL(file);
                });
            });
        }

        function updatePhotoParticles() {
            if (uploadedTextures.length === 0) return;
            
            let texIndex = 0;
            particles.forEach(p => {
                if (p.type === 'photo') {
                    // 赋予新材质
                    const tex = uploadedTextures[texIndex % uploadedTextures.length];
                    p.mesh.material = new THREE.MeshBasicMaterial({ 
                        map: tex, 
                        side: THREE.DoubleSide,
                        transparent: true 
                    });
                    texIndex++;
                }
            });
        }

        function updateStatusUI() {
            const el = document.getElementById('mode-status');
            if (currentState === STATE.TREE) el.textContent = "当前模式: 圣诞树 (合拢)";
            else if (currentState === STATE.DISPERSED) el.textContent = "当前模式: 星海 (散开)";
            else if (currentState === STATE.ZOOM) el.textContent = "当前模式: 回忆 (照片)";
            
            el.style.color = currentState === STATE.TREE ? '#22ff22' : '#ffd700';
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            // 更新背景粒子 Uniforms
            if (bgUniforms) {
                bgUniforms.uTime.value += 0.01;
                
                // 平滑过渡背景粒子的散开状态
                let targetBgState = (currentState === STATE.DISPERSED || currentState === STATE.ZOOM) ? 1.0 : 0.0;
                currentBgDispersal += (targetBgState - currentBgDispersal) * 0.05;
                bgUniforms.uDispersalState.value = currentBgDispersal;
            }

            // 旋转背景粒子
            if (bgParticleSystem) {
                if (currentState === STATE.DISPERSED) {
                     bgParticleSystem.rotation.y += (targetRotation.y - bgParticleSystem.rotation.y) * 0.05;
                     bgParticleSystem.rotation.x += (targetRotation.x - bgParticleSystem.rotation.x) * 0.05;
                } else {
                    bgParticleSystem.rotation.y += 0.001;
                }
            }

            // 平滑旋转 (交互粒子组)
            if (currentState === STATE.DISPERSED) {
                particlesGroup.rotation.y += (targetRotation.y - particlesGroup.rotation.y) * 0.05;
                particlesGroup.rotation.x += (targetRotation.x - particlesGroup.rotation.x) * 0.05;
            } else if (currentState === STATE.TREE) {
                // 树形态下自动缓慢自转
                particlesGroup.rotation.y += 0.002;
            }

            // 粒子漂浮动画 (仅在散开态)
            if (currentState === STATE.DISPERSED) {
                const time = Date.now() * 0.001;
                particles.forEach((p, i) => {
                    if (p.mesh !== zoomedObject) {
                        p.mesh.position.y += Math.sin(time + i) * 0.005;
                    }
                });
            }

            composer.render();
        }

        // 启动
        init();

    </script>
</body>
</html>
