<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 粒子圣诞树 - 手势聚合/离散</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100%; height: 100vh; }
        .input_video { display: none; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); color: white; font-family: sans-serif; pointer-events: none;
        }
        #status {
            position: absolute; top: 10px; left: 10px;
            color: #0f0; font-family: monospace; font-size: 16px; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">正在加载摄像头和模型...</div>
    <div id="status">等待手势识别...</div>
    <div id="canvas-container"></div>
    <video class="input_video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        // 新的 uniform: 0.0 = 聚合成树, 1.0 = 完全扩散
        uniform float uDispersalState; 

        attribute float size;
        attribute vec3 customColor;
        attribute vec3 basePosition; 
        // 每个粒子预先计算好的随机扩散方向
        attribute vec3 explosionDirection;

        varying vec3 vColor;

        void main() {
            vColor = customColor;

            // 1. 计算爆炸后的目标位置
            // 沿预定方向向外移动一定距离 (例如 25.0)
            vec3 dispersedPosition = basePosition + explosionDirection * 25.0;

            // 2. 核心交互：在原始位置和离散位置之间进行线性插值 (mix)
            vec3 newPosition = mix(basePosition, dispersedPosition, uDispersalState);

            // 3. 添加一点基础的自然摆动，让画面更生动
            newPosition.x += sin(uTime * 1.5 + basePosition.y * 0.3) * 0.08 * (1.0 - uDispersalState * 0.5);
            newPosition.z += cos(uTime * 1.5 + basePosition.y * 0.3) * 0.08 * (1.0 - uDispersalState * 0.5);
            // 当扩散时，增加一点随机的上下浮动
            newPosition.y += sin(uTime * 2.0 + basePosition.x) * 0.5 * uDispersalState;

            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
            
            // 扩散时稍微增大粒子尺寸，增强视觉效果
            float currentSize = size * (1.0 + uDispersalState * 0.5);
            gl_PointSize = currentSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float intensity = 1.0 - r; 
            gl_FragColor = vec4(vColor * intensity, 1.0); 
        }
    </script>

    <script>
        let scene, camera, renderer, particleSystem, uniforms;
        // 目标离散状态 (由手势决定)
        let targetDispersalState = 0.0; 
        // 当前实际渲染的离散状态 (用于平滑过渡)
        let currentDispersalState = 0.0; 

        const container = document.getElementById('canvas-container');
        const loadingElement = document.getElementById('loading');
        const statusElement = document.getElementById('status');

        initThree();
        initMediaPipe();
        animate();

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 稍微拉远一点相机，以便看到扩散效果
            camera.position.set(0, 6, 18);
            camera.lookAt(0, 4, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // --- 创建粒子 ---
            const particleCount = 18000; 
            const geometry = new THREE.BufferGeometry();
            
            const basePositions = [];
            const colors = [];
            const sizes = [];
            const explosionDirections = []; // 新增：存储每个粒子的爆炸方向

            const colorGreen = new THREE.Color(0x2f6f2f);
            const colorLightGreen = new THREE.Color(0x4f8f4f);
            const colorRed = new THREE.Color(0xff0000);
            const colorGold = new THREE.Color(0xffd700);
            const colorBlue = new THREE.Color(0x0088ff); // 新增一种装饰色

            for (let i = 0; i < particleCount; i++) {
                // 圣诞树形态生成
                const height = Math.random() * 12;
                const level = height / 12; 
                // 使用指数函数让树顶部更尖，底部更宽
                const radius = Math.pow((1.0 - level), 1.5) * 5.5; 
                const angle = i * 0.1 + level * 25.0;

                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.6;
                const y = height;
                const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.6;

                basePositions.push(x, y, z);

                // --- 计算爆炸方向 ---
                // 基础方向是远离 Y 轴中心
                let dir = new THREE.Vector3(x, y, z).sub(new THREE.Vector3(0, y, 0)).normalize();
                // 加上强烈的随机噪声，使爆炸看起来混乱、有力
                dir.x += (Math.random() - 0.5) * 2.0;
                dir.y += (Math.random() - 0.5) * 2.0; // 允许向上或向下炸
                dir.z += (Math.random() - 0.5) * 2.0;
                dir.normalize();
                explosionDirections.push(dir.x, dir.y, dir.z);

                // 颜色和大小逻辑 (增加了一些蓝色装饰)
                let color, size;
                const ornamentRoll = Math.random();
                if (ornamentRoll > 0.96) { color = colorRed; size = Math.random() * 0.7 + 0.5; }
                else if (ornamentRoll > 0.92) { color = colorGold; size = Math.random() * 0.7 + 0.5; }
                else if (ornamentRoll > 0.89) { color = colorBlue; size = Math.random() * 0.6 + 0.4; }
                else {
                    color = Math.random() > 0.5 ? colorGreen : colorLightGreen;
                    size = Math.random() * 0.25 + 0.1;
                }
                colors.push(color.r, color.g, color.b);
                sizes.push(size);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(basePositions, 3));
            geometry.setAttribute('basePosition', new THREE.Float32BufferAttribute(basePositions, 3));
            geometry.setAttribute('explosionDirection', new THREE.Float32BufferAttribute(explosionDirections, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // --- Uniforms 定义 ---
            uniforms = {
                uTime: { value: 0.0 },
                uDispersalState: { value: 0.0 } // 初始状态为聚合
            };

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            particleSystem = new THREE.Points(geometry, shaderMaterial);
            scene.add(particleSystem);

            // 地面
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshBasicMaterial({ color: 0x0a2a0a, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
            );
            ground.rotation.x = Math.PI / 2;
            ground.position.y = -0.5;
            scene.add(ground);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- MediaPipe Hands 集成与手势分析 ---
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // 用最简模型提高速度
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().then(() => {
                loadingElement.style.display = 'none';
                console.log("摄像头已启动");
            }).catch(err => {
                loadingElement.textContent = "无法访问摄像头";
            });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // --- 手势分析算法：计算张开程度 ---
                // 计算 5 个指尖 (索引 4, 8, 12, 16, 20) 到手腕 (索引 0) 的平均距离
                const wrist = landmarks[0];
                const tipIndices = [4, 8, 12, 16, 20];
                let totalDistance = 0;
                
                tipIndices.forEach(idx => {
                    const tip = landmarks[idx];
                    // 计算简单的 2D 欧几里得距离 (使用归一化坐标足够了)
                    const dx = tip.x - wrist.x;
                    const dy = tip.y - wrist.y;
                    totalDistance += Math.sqrt(dx*dx + dy*dy);
                });

                const avgDistance = totalDistance / 5;

                // --- 阈值映射 ---
                // 根据经验，握拳时平均距离通常小于 0.2，张开时大于 0.35 (归一化坐标下)
                // 这些值可能需要根据具体摄像头情况微调
                const closedThreshold = 0.18;
                const openThreshold = 0.38;

                // 将平均距离映射到 0.0 (握拳/聚合) 到 1.0 (张开/扩散) 的范围
                let openness = (avgDistance - closedThreshold) / (openThreshold - closedThreshold);
                // 钳制结果在 0 到 1 之间
                targetDispersalState = Math.max(0.0, Math.min(1.0, openness));

                statusElement.textContent = `手势识别中: ${targetDispersalState > 0.5 ? "张开 (扩散)" : "握拳 (聚合)"} (强度: ${targetDispersalState.toFixed(2)})`;
                statusElement.style.color = targetDispersalState > 0.5 ? "#ff3333" : "#33ff33";

            } else {
                // 如果没有检测到手，默认缓慢回到聚合状态
                targetDispersalState = 0.0;
                statusElement.textContent = "未检测到手部";
                statusElement.style.color = "#ccc";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            uniforms.uTime.value += 0.01;
            
            // --- 核心：平滑过渡状态 ---
            // 使用线性插值 (lerp) 让当前状态缓慢接近目标状态
            // 0.05 是平滑系数，值越小过渡越慢
            currentDispersalState += (targetDispersalState - currentDispersalState) * 0.05;

            // 更新 uniform 传给着色器
            uniforms.uDispersalState.value = currentDispersalState;

            // 旋转整个系统，在扩散时加快旋转速度增强动感
            if (particleSystem) {
                particleSystem.rotation.y += 0.002 + currentDispersalState * 0.005;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
